# 1. Читаем n, k и список a
n, k = map(int, input().split())
a = list(map(int, input().split()))

# 2. Cоздаем "копилку" для общего ответа
ans = 0

# 3. ▼▼▼ ГЛАВНЫЙ ЦИКЛ ▼▼▼
#    Этот цикл запускает k "независимых задач"
#    r=0 (для цепочки 0, k, 2k...)
#    r=1 (для цепочки 1, 1+k, 1+2k...)
#    ...
for r in range(k):

    # 4. ▼▼▼ РЕШЕНИЕ ОДНОЙ ЦЕПОЧКИ ▼▼▼
    #    Этот код ищет макс. сумму для ОДНОЙ цепочки
    #    (например, [1, 3, 5]), где нельзя брать соседей.
    #    Это хитрый способ (динамическое программирование),
    #    чтобы найти "6" или "4" из наших примеров.
    prev = 0
    prev2 = 0
    i = r  # Начинаем с r-го элемента
    while i < n: # Пока не выйдем за пределы списка
        x = a[i] # Берем текущее число из цепочки

        # Это "заклинание" решает: что выгоднее?
        # 1. Взять текущее число (x + prev2)
        # 2. НЕ брать текущее (prev)
        cur = max(prev, prev2 + x)

        prev2 = prev # "предыдущий" становится "позапрошлым"
        prev = cur   # "текущий" становится "предыдущим"

        i += k # Прыгаем на k шагов вперед

    # 5. ▼▼▼ КОПИЛКА ▼▼▼
    #    prev теперь хранит макс. сумму для этой цепочки (наш "6" или "4")
    #    Мы добавляем его в общую копилку.
    ans += prev

# 6. Печатаем финальный ответ (наш "10")
print(ans)