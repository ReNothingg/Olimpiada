# Задача C. Максим и кодовый замок



"""
Цель: У нас есть большая квадратная "матрица" (таблица с числами). Нам нужно найти в ней "подматрицу" (маленький квадрат) и повернуть этот маленький квадрат на 90 градусов по часовой стрелке.

План:
    1) Прочитать все данные: размер n, саму матрицу, и потом r, c, k.
    2) Найти нужные ячейки в матрице.
    3) Повернуть их.
    4) Вывести всю матрицу обратно.
"""

"""
Шаг 1: Чтение данных
Нам нужно прочитать много всего:
    1) n: одно число, размер всей матрицы.
    2) n строк: в каждой строке n чисел. Это и есть наша матрица.
    3) r, c, k: три числа — строка, столбец и размер квадрата, который нужно повернуть.
Давай начнем с самого простого из этого списка.
Как бы ты написал первую строчку кода, чтобы прочитать одно-единственное число n?
"""

n = int(input())

"""
Теперь нам нужно n раз (для каждой строки) прочитать n чисел.
Как бы ты написал цикл (loop), который повторяется n раз?
"""

matrix = [] # Создаем пустой список
for i in range(n):
    """
    Отлично, `for i in range(n):` — это именно то, что нужно.

    Этот код создаст цикл, который повторится `n` раз. (Переменная `i` будет по очереди `0`, `1`, `2`, ... вплоть до `n-1`).

    Теперь нам нужно две вещи:
    1.  Где-то *до* начала цикла нам нужно создать **пустой список**, в который мы будем складывать строки нашей матрицы.
    2.  *Внутри* цикла нам нужно прочитать одну строку с числами и добавить ее в этот пустой список.

    Давай начнем с первого. Как в Python создать пустой список? (Назовем его, например, `matrix`).
    """

    row = list(map(int, input().split()))
    """
    Теперь, находясь **внутри** этого цикла (`for i in range(n):`), нам нужно сделать две вещи:

    1.  Прочитать одну строку, в которой `n` чисел, разделенных пробелами (например, `'1 5 2'`).
    2.  Добавить эту строку (как список чисел) в наш `matrix`.

    Какой командой мы можем добавить (add) наш новый row (например, [1, 2, 3]) в конец нашего главного списка matrix?
    """

    matrix.append(row)
    """
    В Python, чтобы добавить что-то в конец списка, используется команда .append().
    К этому моменту matrix будет полностью заполнена.
    Остался последний шаг в чтении данных. Нам нужно прочитать последнюю строку с тремя числами: r, c и k.
    """

r, c, k = map(int, input().split())

"""
Именно\! `r, c, k = map(int, input().split())` — это идеальный способ прочитать последнюю строку.

Шаг 2: Поворот (Начало)

Теперь самое интересное. Нам нужно найти и повернуть этот $k \times k$ квадрат.

В примере нам дали:
  * `r = 1`
  * `c = 2`
  * `k = 2`

Это значит "верхний левый угол подматрицы находится в **строке 1**, **столбце 2**" .

Здесь есть о-о-очень важная деталь, на которой ловят почти всех новичков.

В Python (и большинстве языков) списки нумеруются **с НУЛЯ**.
  * Первый элемент — это `[0]`
  * Второй элемент — это `[1]`
  * Третий элемент — это `[2]`

А в задаче (и люди) считают "по-человечески" — **с ЕДИНИЦЫ**.
  * Первая строка — это 1.
  * Вторая строка — это 2.

Видишь несостыковку?

Программа говорит нам: "возьми **строку 1** и **столбец 2**".
Если мы посмотрим на нашу `matrix` в Python, какой *индекс* будет у "человеческой" **строки 1**?
И какой *индекс* будет у "человеческого" **столбца 2**?
"""

# получается у строки 1 - индекс 0, у столбца 2 - индекс 1

"""
Ты совершенно прав.

* "Человеческая" строка 1 = **индекс 0** в Python.
* "Человеческий" столбец 2 = **индекс 1** в Python.

В задаче нам дают `r` и `c` (в примере `r=1`, `c=2`), которые считают с единицы. Чтобы использовать их в `matrix`, нам нужно сначала "перевести" их в нумерацию Python.

Как бы ты изменил `r` и `c` сразу после того, как мы их прочитали, чтобы они указывали на правильные *индексы*?
"""

# отнял 1

"""
Совершенно верно!
Чтобы "человеческое" r=1 стало "питоновским" индекс=0, мы отнимаем 1. Чтобы "человеческое" c=2 стало "питоновским" индекс=1, мы тоже отнимаем 1.
Значит, сразу после чтения r, c, k, мы должны написать:
Теперь r и c — это правильные стартовые индексы нашего квадрата в matrix.
"""
r = r - 1
c = c - 1

"""
Шаг 3: Поворот (Реализация)
Это самый сложный шаг. Нам нужно повернуть квадрат размером `k` на `k`, который начинается с `matrix[r][c]`.

Пример:
`k = 2`
Начало в `r=0`, `c=1`.
Квадрат, который мы крутим, это:
`2 3`
`5 6`

После поворота по часовой стрелке он должен стать:
`5 2`
`6 3`

Делать такой "поворот на месте" (меняя `matrix` напрямую) — очень сложно и легко запутаться.

Есть способ намного проще:

1.  **Скопировать:** Сначала "вырежем" этот $k \times k$ квадрат и скопируем его в новую, *временную* матрицу.
2.  **Повернуть:** Повернем эту *временную* матрицу (что намного проще).
3.  **Вставить:** "Вклеим" повернутые значения обратно в *основную* `matrix`.

Давай начнем с **Шага 1: Скопировать**.

Нам нужно создать новую, временную матрицу (например, `temp_square`), которая будет $k \times k$. И нам нужно пройтись по нашему `matrix` (начиная с `r` и `c`) и скопировать оттуда числа.

Для этого нам понадобятся два цикла `for`, один вложенный в другой. Оба будут работать `k` раз.

  * Внешний цикл (скажем, `i`) будет идти по **строкам** от 0 до `k-1`.
  * Внутренний цикл (скажем, `j`) будет идти по **столбцам** от 0 до `k-1`.

Как бы ты написал эти два вложенных цикла, используя `i` и `j`, чтобы каждый из них повторялся `k` раз?

Поэтому давай вернемся к нашему простому 3-шаговому плану:
    1) Скопировать $k \times k$ квадрат в новый, временный список.
    2) Повернуть этот временный список.
    3) Вставить повернутые значения обратно в matrix.
"""

# r, c - это наши "питоновские" индексы (уже с -1)
# k - размер квадрата

# 1. Создаем пустой список, куда будем копировать
temp_square = []

for i in range(k):      # 2. Внешний цикл по строкам (от 0 до k-1)
    temp_row = []       # 3. Внутри создаем пустую строку для temp_square
    for j in range(k):  # 4. Внутренний цикл по столбцам (от 0 до k-1)
        # Нам нужно взять элемент из ОРИГИНАЛЬНОЙ matrix
        # и добавить его (append) в наш ВРЕМЕННЫЙ temp_row
        value = matrix[r + i][c + j]
        temp_row.append(value)

    temp_square.append(temp_row) # 5. Добавляем собранную строку в наш временный квадрат

"""
Мы остановились на самом-самом хитром моменте: как повернуть `temp_square` (наш скопированный квадрат) на 90 градусов по часовой стрелке.
`temp_square` (старый):
`[2, 3]`
`[5, 6]`
`rotated_square` (новый, который мы хотим получить):
`[5, 2]`
`[6, 3]`
Давай посмотрим, что случилось со **столбцами** из старого квадрата.
1.  Первый столбец был `[2, 5]` (сверху вниз). Во что он превратился в `rotated_square`?
2.  Второй столбец был `[3, 6]`. Во что он превратился?
"""

# [2, 5] [3, 6] Превратится в: [3, 2][6, 5]


rotated_square = []
for i in range(k):
    rotated_square.append([0] * k) # Список из k нулей

# Заполняем его по "заклинанию"
for i in range(k): # i - строка в НОВОМ квадрате
    for j in range(k): # j - столбец в НОВОМ квадрате

        # Вот она, наша строка
        rotated_square[i][j] = temp_square[k - 1 - j][i]

        """
        Шаг 3: Вставка
        Мы почти у финиша. Нам нужно взять этот `rotated_square` и "вклеить" его значения обратно в *основную* `matrix` в то же самое место, откуда мы брали.
        Нам снова понадобятся два цикла (для `i` и `j` от 0 до `k-1`).
        Как бы ты написал код, который берет значение из `rotated_square[i][j]` и кладет его в `matrix`? (Это будет очень похоже на шаг "Копирование", но наоборот).
        `matrix[...][...] = rotated_square[i][j]`
        Что нужно написать в `[...]`?
        """

matrix[r + i][c + j] = rotated_square[i][j]

for i in matrix:
    print(' '.join(map(str, i)))